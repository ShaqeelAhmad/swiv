/*
 * A simple stb style single header library to load a xresources file.
 *
 * The reason this library was created was to allow wayland programs that are
 * meant to be compatible with an X11 program they are trying to replace to
 * carry over some configuration of their X11 counterparts.
 *
 *
 * macros that may be defined:
 *
 * - XRES_CPP may be defined as a string that contains the cpp program to use
 *   on the xresources file. If XRES_CPP is not defined, no preprocessor is
 *   run.
 *
 * - XRES_NO_LOG may be defined to disable the logging done by xres.h
 *
 * - xres_colors should be defined to an array of structs that store the colors
 *   for a name. The rgb.h file generated by gen.c should be included for this.
 *   If xres_colors is not defined, only a basic set of colors are used.
 */

#ifndef XRES_H
#define XRES_H

#include <stdint.h>
#include <stdbool.h>

// Loads the specified file as an xresources file. If file is NULL, it tries to
// load the file in $XRES_PATH or $HOME/.Xresources or $HOME/.Xdefaults.
//
// Returns true if at least 1 entry was read properly and would log any errors.
// false is returned if it failed to read any entry.
bool xres_load(char *file);

// Matches the name with the entries.
// Returns the resource value on a successful match, returns NULL on failure.
char *xres_get(char *name);

// Set the r, g, b, a arguments to the value of color.
// Returns true on success and false on failure.
bool xres_color(char *color, uint8_t *r, uint8_t *g, uint8_t *b, uint8_t *a);

// Unloads the resources, including values returned by xres_get().
void xres_unload(void);

#endif // XRES_H

#ifdef XRES_IMPLEMENTATION

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <unistd.h>
#include <sys/wait.h>

static void
xres_log(char *fmt, ...)
{
#ifndef XRES_NO_LOG
	va_list ap;
	va_start(ap, fmt);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
#endif
}

struct xres_entry {
	char *key;
	char *value;
};

static struct xres_entry *xres_entries = NULL;
static size_t xres_entries_len = 0;

bool
xres_load(char *file)
{
	char *filename = file;
	if (file == NULL) {
		filename = getenv("XRES_PATH");
		if (filename == NULL) {
			static char path[PATH_MAX];
			char *home = getenv("HOME");
			if (home == NULL) {
				xres_log("Failed to get $HOME\n");
				return false;
			}
			size_t homelen = strlen(home);
			memcpy(path, home, homelen);
			strcpy(path + homelen, "/.Xresources");

			if (access(path, R_OK) < 0) {
				strcpy(path + homelen, "/.Xdefaults");
			}
			if (access(path, R_OK) < 0) {
				xres_log("No valid path xresource file found; %s: %s\n",
						path, strerror(errno));
				return false;
			}
			filename = path;
		}
	}

#ifdef XRES_CPP
	int pfds[2];
	if (pipe(pfds) < 0) {
		xres_log("Failed to create pipe for preprocessor: %s\n",
				strerror(errno));
		return false;
	}
	int readfd  = pfds[0];
	int writefd = pfds[1];

	pid_t pid = fork();
	if (pid == 0) {
		close(readfd);
		if (dup2(writefd, STDOUT_FILENO) < 0) {
			xres_log("Failed to set stdout for command %s: %s\n",
					XRES_CPP, strerror(errno));
			exit(1);
		}
		execlp(XRES_CPP, XRES_CPP, filename, NULL);
		xres_log("Failed to execute preprocessor %s: %s\n",
				XRES_CPP, strerror(errno));
		exit(1);
	}

	close(writefd);
	if (pid < 0) {
		xres_log("Failed to fork process for executing preprocessor: %s\n",
				strerror(errno));
		close(readfd);
		return false;
	}

	FILE *f = fdopen(readfd, "r");
	if (f == NULL) {
		xres_log("Failed to open pipe for reading: %s\n", strerror(errno));
		close(readfd);
		return false;
	}
#else
	FILE *f = fopen(filename, "r");
	if (f == NULL) {
		xres_log("Failed to open xresource file %s: %s\n",
				filename, strerror(errno));
		return false;
	}
#endif

	char *line = NULL;
	size_t linelen = 0;
	size_t lineno = 0;
	xres_entries_len = 0;
	while (getline(&line, &linelen, f) >= 0) {
		lineno++;
		char *s = line;

		while (isspace(*s))
			s++;

		if (*s == '!' || *s == '#' || *s == '\0')
			continue;

		char *key = s;
		while (*s && *s != ':')
			s++;
		size_t keylen = s - key;

		if (*s != ':') {
			xres_log("%s:%zu: error: can't find colon ':', skipping line...\n",
					filename, lineno);
			continue;
		}

		s++;
		while (isspace(*s))
			s++;
		char *value = s;

		while (*s && !isspace(*s))
			s++;
		size_t valuelen = s - value;

		char *p = emalloc(keylen + 1 + valuelen + 1);
		key = memcpy(p, key, keylen);
		key[keylen] = 0;
		value = memcpy(p + keylen + 1, value, valuelen);
		value[valuelen] = 0;

		xres_entries_len++;
		xres_entries = erealloc(xres_entries,
				sizeof(*xres_entries)*xres_entries_len);
		xres_entries[xres_entries_len-1].key = key;
		xres_entries[xres_entries_len-1].value = value;
	}

	free(line);
	fclose(f);
#ifdef XRES_CPP
	waitpid(pid, NULL, 0);
#endif

	return xres_entries_len > 0;
}

static bool
xres_match(char *t, char *s)
{
	for (;*t && *s;) {
		switch (*t) {
		case '*':
			t++;
			if (!*t)
				return true;

			if (xres_match(t, s))
				return true;
			t--;
			s++;
			break;
		case '?':
			t++, s++;
			break;
		default:
			if (*t != *s)
				return false;
			t++, s++;
		}
	}

	return *t == *s;
}

char *
xres_get(char *name)
{
	for (size_t i = 0; i < xres_entries_len; i++) {
		if (xres_match(xres_entries[i].key, name)) {
			return xres_entries[i].value;
		}
	}
	return NULL;
}

void
xres_unload(void)
{
	for (size_t i = 0; i < xres_entries_len; i++) {
		free(xres_entries[i].key);
	}
	free(xres_entries);
	xres_entries = NULL;
	xres_entries_len = 0;
}

#ifndef xres_colors
// only define basic colors if xres_colors is not defined.
struct { char *name; uint8_t r; uint8_t g; uint8_t b;} xres_colors_default[] = {
	{"black",   0,   0,   0},
	{"white", 255, 255, 255},
	{"red",   255,   0,   0},
	{"green",   0, 255,   0},
	{"blue",    0,   0, 255},
};
#define xres_colors xres_colors_default
#endif

static int
xres_hexint(char c)
{
	if ('A' <= c && c <= 'F')
		return c - 'A' + 10;
	if ('a' <= c && c <= 'f')
		return c - 'a' + 10;
	if ('0' <= c && c <= '9')
		return c - '0';

	return -1;
}

static bool
xres_parse_hex(char **s, uint8_t *c)
{
	if ((*s)[0] == '\0' || (*s)[1] == '\0')
		return false;
	int l = xres_hexint((*s)[0]);
	int r = xres_hexint((*s)[1]);
	if (l < 0 || r < 0)
		return false;

	*s += 2;
	*c = (l * 16 + r);
	return true;
}

bool
xres_color(char *color, uint8_t *r, uint8_t *g, uint8_t *b, uint8_t *a)
{
	if (color == NULL || *color == '\0')
		return false;

	if (*color != '#') {
		for (size_t i = 0; i < sizeof(xres_colors) / sizeof(xres_colors[0]); i++) {
			if (strcasecmp(xres_colors[i].name, color) == 0) {
				*r = xres_colors[i].r;
				*g = xres_colors[i].g;
				*b = xres_colors[i].b;
				*a = 0xFF;
				return true;
			}
		}
		return false;
	}
	color++;

	if (!xres_parse_hex(&color, r))
		return false;
	if (!xres_parse_hex(&color, g))
		return false;
	if (!xres_parse_hex(&color, b))
		return false;

	if (*color) {
		if (!xres_parse_hex(&color, a))
			return false;
	} else {
		*a = 0xFF;
	}

	return true;
}

#endif // XRES_IMPLEMENTATION
